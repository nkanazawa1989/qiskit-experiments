# This code is part of Qiskit.
#
# (C) Copyright IBM 2021.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""Cross resonance Hamiltonian tomography experiment analysis."""

from collections import defaultdict
from itertools import product
from typing import List, Union

import numpy as np

import qiskit_experiments.curve_analysis as curve
import qiskit_experiments.data_processing as dp
from qiskit_experiments.database_service.device_component import Qubit
from qiskit_experiments.exceptions import AnalysisError
from qiskit_experiments.framework import AnalysisResultData, CompositeAnalysis, ExperimentData


class TomographyElementAnalysis(curve.CurveAnalysis):
    r"""A class to analyze cross resonance Hamiltonian tomography experiment.

    # section: fit_model
        The following equations are used to approximate the dynamics of
        the target qubit Bloch vector.

        .. math::

            \begin{align}
                F_x(t) &= \frac{1}{\Omega^2} \left(
                    - p_z p_x + p_z p_x \cos(\Omega t') +
                    \Omega p_y \sin(\Omega t') \right) + b \tag{1} \\
                F_y(t) &= \frac{1}{\Omega^2} \left(
                    p_z p_y - p_x p_y \cos(\Omega t') -
                    \Omega p_x \sin(\Omega t') \right) + b \tag{2} \\
                F_z(t) &= \frac{1}{\Omega^2} \left(
                    p_z^2 + (p_x^2 + p_y^2) \cos(\Omega t') \right) + b \tag{3}
            \end{align}

        where :math:`t' = t + t_{\rm offset}` with :math:`t` is pulse duration to scan
        and :math:`t_{\rm offset}` is an extra fit parameter that may represent the edge effect.
        The :math:`\Omega = \sqrt{p_x^2+p_y^2+p_z^2}` and :math:`p_x, p_y, p_z, b` are fit parameters.
        The fit functions :math:`F_x, F_y, F_z` approximate the Pauli expectation
        values :math:`\langle \sigma_x (t) \rangle, \langle \sigma_y (t) \rangle,
        \langle \sigma_z (t) \rangle` of the target qubit, respectively.

        Based on the fit result, cross resonance Hamiltonian coefficients can be written as

        .. math::

            ZX &= \frac{p_{x, 0} - p_{x, 1}}{2} \\
            ZY &= \frac{p_{y, 0} - p_{y, 1}}{2} \\
            ZZ &= \frac{p_{z, 0} - p_{z, 1}}{2} \\
            IX &= \frac{p_{x, 0} + p_{x, 1}}{2} \\
            IY &= \frac{p_{y, 0} + p_{y, 1}}{2} \\
            IZ &= \frac{p_{z, 0} + p_{z, 1}}{2}

        In this analysis, the initial guess is generated by the following equations.

        .. math::

            p_x &= \omega \cos(\theta) \cos(\phi) \\
            p_y &= \omega \cos(\theta) \sin(\phi) \\
            p_z &= \omega \sin(\theta)

        where :math:`\omega` is the mean oscillation frequency of eigenvalues,
        :math:`\theta = \cos^{-1}\sqrt{\frac{\max F_z - \min F_z}{2}}`
        and :math:`\phi \in [-\pi, \pi]`.

    # section: fit_parameters

        defpar t_{\rm off}:
            desc: Offset to the pulse duration. For example, if pulse envelope is
                a flat-topped Gaussian, two Gaussian edges may become an offset duration.
            init_guess: Computed as :math:`N \sqrt{2 \pi} \sigma` where the :math:`N` is number of
                pulses and :math:`\sigma` is Gaussian sigma of rising and falling edges.
                Note that this implicitly assumes the :py:class:`~qiskit.pulse.library\
                .parametric_pulses.GaussianSquare` pulse envelope.
            bounds: [0, None]

        defpar p_x:
            desc: Fit parameter of oscillations.
            init_guess: See fit model section.
            bounds: None

        defpar p_y:
            desc: Fit parameter of oscillations.
            init_guess: See fit model section.
            bounds: None

        defpar p_z:
            desc: Fit parameter of oscillations.
            init_guess: See fit model section.
            bounds: None

        defpar b:
            desc: Vertical offset of oscillations. This may indicate the state preparation and
                measurement error.
            init_guess: 0
            bounds: None

    # section: see_also
        qiskit_experiments.library.characterization.CrossResonanceHamiltonian

    """
    __series__ = [
        curve.SeriesDef(
            name="cr_tomo_x",
            fit_func=lambda x, t_off, px, py, pz, b: curve.fit_function.bloch_oscillation_x(
                x + t_off, px=px, py=py, pz=pz, baseline=b
            ),
            filter_kwargs={"meas_basis": "x"},
            plot_color="red",
            plot_symbol="o",
        ),
        curve.SeriesDef(
            name="cr_tomo_y",
            fit_func=lambda x, t_off, px, py, pz, b: curve.fit_function.bloch_oscillation_y(
                x + t_off, px=px, py=py, pz=pz, baseline=b
            ),
            filter_kwargs={"meas_basis": "y"},
            plot_color="green",
            plot_symbol="^",
        ),
        curve.SeriesDef(
            name="cr_tomo_z",
            fit_func=lambda x, t_off, px, py, pz, b: curve.fit_function.bloch_oscillation_z(
                x + t_off, px=px, py=py, pz=pz, baseline=b
            ),
            filter_kwargs={"meas_basis": "z"},
            plot_color="blue",
            plot_symbol="x",
        ),
    ]

    @classmethod
    def _default_options(cls):
        """Return the default analysis options."""
        default_options = super()._default_options()
        default_options.data_processor = dp.DataProcessor(
            input_key="counts",
            data_actions=[dp.Probability("1"), dp.BasisExpectationValue()],
        )
        default_options.xlabel = "Flat top width"
        default_options.ylabel = "<X(t)>,<Y(t)>,<Z(t)>"
        default_options.xval_unit = "s"
        default_options.ylim = (-1, 1)

        return default_options

    def _generate_fit_guesses(
        self, user_opt: curve.FitOptions
    ) -> Union[curve.FitOptions, List[curve.FitOptions]]:
        """Compute the initial guesses.

        Args:
            user_opt: Fit options filled with user provided DICguess and bounds.

        Returns:
            List of fit options that are passed to the fitter function.
        """
        user_opt.bounds.set_if_empty(t_off=(0, np.inf), b=(-1, 1))
        user_opt.p0.set_if_empty(b=1e-9)

        x_data = self._data(series_name=f"cr_tomo_x")
        y_data = self._data(series_name=f"cr_tomo_y")
        z_data = self._data(series_name=f"cr_tomo_z")

        omega_xyz = []
        for data in (x_data, y_data, z_data):
            ymin, ymax = np.percentile(data.y, [10, 90])
            if ymax - ymin < 0.2:
                # oscillation amplitude might be almost zero,
                # then exclude from average because of lower SNR
                continue
            fft_freq = curve.guess.frequency(data.x, data.y)
            omega_xyz.append(fft_freq)
        if omega_xyz:
            omega = 2 * np.pi * np.average(omega_xyz)
        else:
            omega = 1e-3

        zmin, zmax = np.percentile(z_data.y, [10, 90])
        theta = np.arccos(np.sqrt((zmax - zmin) / 2))

        # The FFT might be up to 1/2 bin off
        df = 2 * np.pi / ((z_data.x[1] - z_data.x[0]) * len(z_data.x))

        fit_options = []
        for omega_shifted in [omega, omega - df / 2, omega + df / 2]:
            for phi in np.linspace(-np.pi, np.pi, 5):
                new_opt = user_opt.copy()
                new_opt.p0.set_if_empty(
                    px=omega_shifted * np.cos(theta) * np.cos(phi),
                    py=omega_shifted * np.cos(theta) * np.sin(phi),
                    pz=omega_shifted * np.sin(theta),
                )
                fit_options.append(new_opt)
        if omega < df:
            # empirical guess for low frequency case
            lowf_guess = user_opt.copy()
            lowf_guess.p0.set_if_empty(px=omega, py=omega, pz=0)
            fit_options.append(lowf_guess)

        return fit_options

    def _evaluate_quality(self, fit_data: curve.FitData) -> Union[str, None]:
        """Algorithmic criteria for whether the fit is good or bad.

        A good fit has:
            - If chi-squared value is less than 3.
        """
        if fit_data.reduced_chisq < 3:
            return "good"

        return "bad"



# pylint: disable=line-too-long
class CrossResonanceHamiltonianAnalysis(CompositeAnalysis):
    r"""A class to analyze cross resonance Hamiltonian tomography experiment.

    # section: fit_model
        The following equations are used to approximate the dynamics of
        the target qubit Bloch vector.

        .. math::

            \begin{align}
                F_x(t) &= \frac{1}{\Omega^2} \left(
                    - p_z p_x + p_z p_x \cos(\Omega t') +
                    \Omega p_y \sin(\Omega t') \right) + b \tag{1} \\
                F_y(t) &= \frac{1}{\Omega^2} \left(
                    p_z p_y - p_x p_y \cos(\Omega t') -
                    \Omega p_x \sin(\Omega t') \right) + b \tag{2} \\
                F_z(t) &= \frac{1}{\Omega^2} \left(
                    p_z^2 + (p_x^2 + p_y^2) \cos(\Omega t') \right) + b \tag{3}
            \end{align}

        where :math:`t' = t + t_{\rm offset}` with :math:`t` is pulse duration to scan
        and :math:`t_{\rm offset}` is an extra fit parameter that may represent the edge effect.
        The :math:`\Omega = \sqrt{p_x^2+p_y^2+p_z^2}` and :math:`p_x, p_y, p_z, b` are fit parameters.
        The fit functions :math:`F_x, F_y, F_z` approximate the Pauli expectation
        values :math:`\langle \sigma_x (t) \rangle, \langle \sigma_y (t) \rangle,
        \langle \sigma_z (t) \rangle` of the target qubit, respectively.

        Based on the fit result, cross resonance Hamiltonian coefficients can be written as

        .. math::

            ZX &= \frac{p_{x, 0} - p_{x, 1}}{2} \\
            ZY &= \frac{p_{y, 0} - p_{y, 1}}{2} \\
            ZZ &= \frac{p_{z, 0} - p_{z, 1}}{2} \\
            IX &= \frac{p_{x, 0} + p_{x, 1}}{2} \\
            IY &= \frac{p_{y, 0} + p_{y, 1}}{2} \\
            IZ &= \frac{p_{z, 0} + p_{z, 1}}{2}

        In this analysis, the initial guess is generated by the following equations.

        .. math::

            p_x &= \omega \cos(\theta) \cos(\phi) \\
            p_y &= \omega \cos(\theta) \sin(\phi) \\
            p_z &= \omega \sin(\theta)

        where :math:`\omega` is the mean oscillation frequency of eigenvalues,
        :math:`\theta = \cos^{-1}\sqrt{\frac{\max F_z - \min F_z}{2}}`
        and :math:`\phi \in [-\pi, \pi]`.

    # section: fit_parameters

        defpar t_{\rm off}:
            desc: Offset to the pulse duration. For example, if pulse envelope is
                a flat-topped Gaussian, two Gaussian edges may become an offset duration.
            init_guess: Computed as :math:`N \sqrt{2 \pi} \sigma` where the :math:`N` is number of
                pulses and :math:`\sigma` is Gaussian sigma of rising and falling edges.
                Note that this implicitly assumes the :py:class:`~qiskit.pulse.library\
                .parametric_pulses.GaussianSquare` pulse envelope.
            bounds: [0, None]

        defpar p_x:
            desc: Fit parameter of oscillations.
            init_guess: See fit model section.
            bounds: None

        defpar p_y:
            desc: Fit parameter of oscillations.
            init_guess: See fit model section.
            bounds: None

        defpar p_z:
            desc: Fit parameter of oscillations.
            init_guess: See fit model section.
            bounds: None

        defpar b:
            desc: Vertical offset of oscillations. This may indicate the state preparation and
                measurement error.
            init_guess: 0
            bounds: None

    # section: see_also
        qiskit_experiments.library.characterization.CrossResonanceHamiltonian
        qiskit_experiments.library.characterization.TomographyElementAnalysis

    """

    def _run_analysis(self, experiment_data: ExperimentData):

        # wait for child experiments to complete
        super()._run_analysis(experiment_data)

        if len(self.component_analysis()) != 2:
            raise AnalysisError(
                f"More than two analyses are found. {self.__class__.__name__} doesn't know "
                "how to compute CR Hamiltonian coefficients with more than 2 curves."
            )

        analysis_results = []

        for control in ("z", "i"):
            for target in ("x", "y", "z"):
                fit0 = experiment_data.child_data(0).analysis_results(f"cr_tomo_p{target}0")
                fit1 = experiment_data.child_data(1).analysis_results(f"cr_tomo_p{target}1")

                if control == "z":
                    coef = 0.5 * (fit0.value - fit1.value) / (2 * np.pi)
                else:
                    coef = 0.5 * (fit0.value + fit1.value) / (2 * np.pi)

                new_data = AnalysisResultData(
                    name=f"omega_{control}{target}",
                    value=coef,
                    quality="good" if fit0.quality == fit1.quality == "good" else "bad",
                    extra={"unit": "Hz"},
                )

                analysis_results.append(new_data)

        return analysis_results, []
